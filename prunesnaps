#!/bin/bash
set -e
#set -xv

USAGE1='usage: prunesnaps [options] dataset [dataset [...]]'
USAGE="$USAGE1
options:
    -h: print this help message and exit
    -n: no changes (dry run)
    -v: be verbose
    -r: number of hours to keep hourly snapshots for
    -d: number of days to keep daily snapshots for
    -w: number of weeks to keep weekly snapshots for
    -m: number of months to keep monthly snapshots for
    -y: number of years to keep yearly snapshots for"

DRYRUN=0
VERBOSE=0
typeset -A PRUNE SECONDS
PRUNE[r]=-1
PRUNE[d]=-1
PRUNE[w]=-1
PRUNE[m]=-1
PRUNE[y]=-1
SECONDS[r]=$(( 60 * 60 ))
SECONDS[d]=$(( 60 * 60 * 24 ))
SECONDS[w]=$(( 60 * 60 * 24 * 7 ))
SECONDS[m]=$(( 60 * 60 * 24 * 30 ))  # monthish
SECONDS[y]=$(( 60 * 60 * 24 * 365 ))
DATASETS=()
NOW=$(date --utc +%s)


# always work in UTC, affects the output of zfs commands
export TZ=UTC


function checkarr() {
    # requires bash >= 4.3
    typeset -n t="$1"
    [ "${#t[@]}" -gt 0 ] || { echo "ERROR: required array variable \$$1 is empty"; return 1; } >&2
}

function isintorempty() {
    # if the value referenced by the var *name* passed in $1 is:
    #   an integer: return 0
    #   empty: return 1
    #   not an integer: return 2
    [ -n "${!1}" ] || return 1
    [ "${!1}" -eq "${!1}" ] 2>/dev/null || { rc=$?; [ $rc -ne 2 ] || { echo "ERROR: invalid non-integer value for ${2:-"\$$1"}: ${!1}"; }; return $rc; } >&2
    return 0
}

function isint() {
    if isintorempty $1 $2; then
        return 0
    else
        [ $? -ne 1 ] || echo "ERROR: ${2:-"\$$1"} value cannot be empty string" >&2
        return 1
    fi
}

function has_key() {
    # has_key ARRAY_NAME key
    typeset -n t="$1"
    [ ${t[$2]+foo} ]
}

function check_output() {
    [ $VERBOSE -eq 1 ] && set -x
    "$@" || { exit $?; } 2>/dev/null
    { set +x; } 2>/dev/null  # not necessary if we're always called in a subshell
}

function setopts() {
    local exit=
    while getopts ':hnvr:d:w:m:y:' opt; do
        case $opt in
            h)
                echo "$USAGE"
                exit 0
                ;;
            n)
                DRYRUN=1
                ;;
            v)
                VERBOSE=1
                ;;
            r|d|w|m|y)
                PRUNE[$opt]="$OPTARG"
                isint OPTARG "-$opt" || exit=2
                ;;
            :)
                echo "ERROR: missing option argument for -$OPTARG" >&2
                exit=2
                ;;
            \?)
                echo "ERROR: invalid option: -$OPTARG" >&2
                exit=2
                ;;
        esac
    done
    shift "$((OPTIND - 1))"
    DATASETS=("$@")
    checkarr DATASETS || exit=2
    [ -z "$exit" ] || { echo "$USAGE1"; echo 'hint: `prunesnaps -h` for full help'; exit $exit; } >&2
}

function validate_opts() {
    #for k in ${!PRUNE[@]}; do echo "before $k ${PRUNE[$k]}"; done
    # FIXME: should be -ge than the previous period? no, but if there are no >0 after a <0 period then all after >0 should be 0?
    # -r 12 -m 12 = keep hourlies for 12 hours, anything older means keep monthlies for 12 months
    for period in r d w m y; do
        PRUNE[$period]=$((PRUNE[$period] * ${SECONDS[$period]}))
    done
    #for k in ${!PRUNE[@]}; do echo "after  $k ${PRUNE[$k]}"; done
}

function validate_datasets() {
    local exit=
    for dataset in "${DATASETS[@]}"; do
        # subshell so we can check all datasets before exiting
        (check_output zfs get -H -o name name "$dataset" >/dev/null) || exit=2
    done
    [ -z "$exit" ] || { echo "ERROR: invalid dataset name(s)"; exit $exit; }
}

function setsnaps() {
    #dataset="$1"
    local snap creation name snapname
    #local snaps=()
    #local times=()
    #check_output zfs get -H -o name name "$dataset" >/dev/null
    #while read snap creation || exit $?; do
    while read snap creation || { [ "$snap" -eq 0 ] && break || exit $snap; }; do
        # read exits 1 on the unterminated single field printf
        #[ ! ${!PRUNESNAP
        name=${snap%@*}
        snapname=${snap#*@}
        typeset -n snaps="SNAPS_${name//\//_}"
        typeset -n times="TIMES_${name//\//_}"
        #if ! has_key SNAPS $name; then
        #    SNAPS[$name]=()
        #    TIMES[$name]=()
        #fi
        [ ${#snaps[@]} -ne 0 ] || snaps=()
        [ ${#times[@]} -ne 0 ] || times=()
        snaps+=("$snapname")
        times+=("$creation")
        # < <((check_output ...); printf $?) doesn't work because of set -e
    done < <((check_output zfs list -Hp -t snapshot -o name,creation -S creation) && printf 0 || printf $?)
}

function printsnaps() {
    dataset="$1"
    typeset -n snaps="SNAPS_${dataset//\//_}"
    typeset -n times="TIMES_${dataset//\//_}"
    local last
    local i=0
    local offset="$NOW"
    for period in r d w m y; do
        # FIXME: with an offset you're saying "-r 12 -d 10" means keep 12 hours of hourlies plus 10 days of dailies after those
        # without an offset it means keep 12 hours of hourlies plus 9.5 days of dailies after those
        # IE is it more intuitive to have the defined windows be additive or absolute
        offset="$last"
        last=$((times[$i] + ${SECONDS[$period]}))
        for (( ; i < ${#snaps[@]}; i++ )); do
            age=$(( $NOW - ${times[$i]} ))
            since_last=$(( $last - ${times[$i]} ))
            if [ ${PRUNE[$period]} -ge 0 -a $(( $NOW - ${times[$i]} )) -ge ${PRUNE[$period]} ]; then
                echo "$i NEXT period $period snapname ${snaps[$i]} age $age since last $since_last max age ${PRUNE[$period]} last $last"
                break
            elif [ ${PRUNE[$period]} -ge 0 -a $(( $last - ${times[$i]} )) -lt ${SECONDS[$period]} ]; then
                echo "$i PRUN period $period snapname ${snaps[$i]} age $age since last $since_last max age ${PRUNE[$period]} last $last"
            else
                echo "$i KEEP period $period snapname ${snaps[$i]} age $age since last $since_last max age ${PRUNE[$period]} last $last"
                last=${times[$i]}
            fi
        done
    done
}

setopts "$@"
validate_opts
validate_datasets
setsnaps

for d in "${DATASETS[@]}"; do
    printsnaps $d
done
